---
title: "Kinetochore-microtubule error correction"
subtitle: "Simple model"
author: "Marek Gierlinski"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    css: tabbed_notebook.css
  pdf_document:
    number_sections: yes
---

```{r options, echo=FALSE}
library(knitr)
library(kableExtra)
library(gridExtra)
suppressMessages(library(viridis))
suppressMessages(library(dplyr))
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  cache = TRUE
)
options(width = 1000)
options(knitr.table.format = "html")
```

```{css echo=FALSE}
pre code, pre, code {
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}
```

```{r kable_functions}
myKable <- function(df, row.names=FALSE, col.names=NA, digits=2, bootstrap="condensed") {
  kable(df, format="html", row.names=row.names, col.names=col.names, digits=digits) %>% kable_styling(bootstrap_options=bootstrap, full_width=FALSE, position="left", font_size=12)
}
```


Collaborators: Tomo Tanaka

[Proposal]()

Notebooks: [1](http://www.compbio.dundee.ac.uk/user/mgierlinski/kinerr/doc/Notes.1.nb.html)

```{r setup, cache=FALSE, echo=FALSE}
source("../R/setup.R")
source("../R/lib.R")
source("../R/plots.R")
source("../R/tests.R")
```

# {.tabset}

## Model

In this document we present a simple computer model for error correction in kinetochore-microtubule interaction during bi-orientation. The configuration is very simple, perhaps simplistic, but it can test the underlying mechanisms. We focus on two situations:

- KT detachment from MT ends creates unattached KTs before the next lateral attachment is formed (model "M1")
- End-on attachment is directly replaced by the lateral attachment without producing unattached KTs (model "M2")

### Setup

In our model there are two kinetochores, left and right. Each of them can be in one of the following attachment states:

- none
- lateral
- endon
- dual

Dual attachment represents the second model, when the lateral attachment is formed on top of the existing end-on attachment. In addition to the connection state, we also record which spindle pole (left or right) the kinetochore is attached to. Therefore, the state of the system can be briefly denoted as, e.g.:

```
lateral-R endon-R
```

The left KT has a lateral attachment to a microtubule extending from the right spindle. The right kinetochore has an end-on attachment to a microtubule extending from the right spindle.

### Dynamics

Transition between states are governed by a Poisson law. That is, at any given time the probability of transition from, e.g., lateral to end-on attachment is constant. Each transition happens randomly a rate, $R$, expressed in events per minute.

The model allows for other probability prescriptions, for example, the transition time can be expressed by a Gaussian probability.

The simulation is a sequence of events. The time of the next event is randomly drawn based on the current event and the probability law assumed. The events are generated for both kinetochores concurrently, until the final stable configuration is established (`endon-L endon-R`).

### Model 1

Here we assume that the end-on detachment and formation of the lateral attachment are independent. For illustration purposes, we show how the model works on the left kinetochore, but obviously, it works on both. Also, microtubules can reach kinetochores at the opposite side. The sequence of events in this model is as follows.

Let's start with an unattached microtubule.

```{r default_parameters}
defaultParameters <- function() {
  parametersRates(
    formation = 0.5,
    conversion = 2,
    detachment = 1,
    replacement = 0.5,
    knockoff = 1e16
  )
}
M1.parnames <- c("formation", "conversion", "detachment")
M2.parnames <- c("replacement", "knockoff", "conversion")

defPars <- function(model) {
  pars <- defaultParameters()
  if(model == "M1") {
    parnames = M1.parnames
  } else {
    parnames = M2.parnames
  }
  P <- lapply(parnames, function(pn) {
    data.frame(parameter=pn, value=pars[[pn]]$value$rate)
  })
  do.call(rbind, P)
}
```



```{r plot_lateral_attachement, fig.width=4, fig.height=2}
par <- defaultParameters()
sc <- sisterChromatids(par, model="M1")
plotSisterChromatids(sc)
```

A lateral attachment is created at formation rate $R_\mathrm{form}$.

```{r plot_emplty_sc, fig.width=4, fig.height=2}
sc <- formLateralAttachment(sc, "L", "L")
plotSisterChromatids(sc)
```

Next, the lateral attachment is converted into the end-on attachment, at conversion rate $R_\mathrm{conv}$:

```{r plot_endon_attachement, fig.width=4, fig.height=2}
sc <- convertAttachment(sc, "L")
plotSisterChromatids(sc)
```

Finally, the microtubule is detached at detachment rate $R_\mathrm{det}$:

```{r plot_detachment, fig.width=4, fig.height=2}
sc <- detachKT(sc, "L")
plotSisterChromatids(sc)
```


### Model 2

In this model we assume that the end-on detachment happens only upon formation of the lateral attachment.  Hence, we never observe a detached state. This is the sequence of events. Now, we start with an end-on attachment:


```{r plot_endon_attachement_2, fig.width=4, fig.height=2}
sc <- sisterChromatids(par, model="M2")
sc <- formLateralAttachment(sc, "L", "L")
sc <- convertAttachment(sc, "L")
plotSisterChromatids(sc)
```

Then, a lateral attachment can be created at the same KT, at replacement rate $R_\mathrm{rep}$. This is the same process as "formation" in model 1, but we call it "replacement" here, for distinction. For a moment we have a "dual" attachment.

```{r plot_dual_attachement, fig.width=4, fig.height=2}
sc <- formDualAttachment(sc, "L", "L")
plotSisterChromatids(sc)
```

which, in turn, leads to the lateral attachment by knocking off the end-on MT. Here we assume no delay, though a knock-off rate $R_\mathrm{ko}$ can be introduced.

```{r plot_dual_detachment, fig.width=4, fig.height=2}
sc <- knockoffKT(sc, "L")
plotSisterChromatids(sc) 
```

As before, the lateral attachment is converted into end-on at conversion rate $R_\mathrm{conv}$.

```{r plot_endon_attachement_3, fig.width=4, fig.height=2}
sc <- convertAttachment(sc, "L")
plotSisterChromatids(sc)
```

In this model, the detachment rate does not come into effect.

## Tests

### "GenerateTime" function

First, I test my internal function for accuracy. Using all default parameters. The red curves show the theoretical exponential distribution.

```{r generate_time_test}
funtest <- readRDS(paste0(projectDir, "data/sim_test1.rds"))
```

```{r generate_time_test_plot, fig.width=8, fig.height=3}
plotDurationDistribution(funtest, par, ncol=5)
```

Here is a table with mean and SE for these:

```{r generate_time_test_table}
df <- funtest %>% group_by(event) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))
myKable(df, digits=4)
```

### Full simulation

We undertake a few simple tests to confirm that the model is working correctly. Specifically, we build the distribution of event duration over many simulation runs. The mean duration should be as in the input parameters. We set the following parameters: $R_\mathrm{form} = 0.5~\mathrm{min}^{-1}$, $R_\mathrm{conv} = 2~\mathrm{min}^{-1}$ and $R_\mathrm{det} = 1~\mathrm{min}^{-1}$.

```{r simulation_test_read}
simtest1 <- readRDS(paste0(projectDir, "data/sim_test2.rds"))
simtest2 <- readRDS(paste0(projectDir, "data/sim_test3.rds"))
simtest3 <- readRDS(paste0(projectDir, "data/sim_test4.rds"))
```

#### Model 1

Here are measured distributions of event duration versus theoretical exponential distributions.

```{r simulation_test_results_M1_plot, fig.width=7, fig.height=3}
par <- defaultParameters()
plotDurationDistribution(simtest1, par)
```

And these are mean of these distributions, which should correspond to 1 / rate (that is we expect means of conversion = 0.5, detachment = 1 and formation = 2):

```{r simulation_test_results_M1}
df <- simtest1 %>% group_by(event) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))
myKable(df, digits=4)
```

There is a good agreement between generated and theoretical means.

```{r random_generator_test, eval=FALSE}
rgTest <- function(n, rates=c(2, 1e16, 0.5)) {
  P <- lapply(1:n, function(i) {
    d <- lapply(rates, function(rate) {
      data.frame(
        rate=rate,
        duration=rexp(1, rate)
      )
    })
    do.call(rbind, d)
  })
  do.call(rbind, P)
}

rgt <- rgTest(1000)
df <- rgt %>% group_by(rate) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))

myKable(df, digits=4)
```


#### Model 2

The same for the "M2" model:

```{r simulation_test_results_M2_plot, fig.width=7, fig.height=3}
par <- defaultParameters()
plotDurationDistribution(simtest2, par)
```

and the mean times:

```{r simulation_test_results_M2}
df <- simtest2 %>% group_by(event) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))
myKable(df, digits=4)
```

They are reasonably close to the input parameters. In the second test the "knockoff" is very short: this corresponds to infinitesimal delay of detachment after lateral attachment. When we set a knockoff rate of 1 per minute, we get:

```{r simulation_test_results_M2a_plot, fig.width=7, fig.height=3}
par2 <- parametersRates(replacement=0.5, knockoff=1, conversion=2)
plotDurationDistribution(simtest3, par2)
```


```{r simulation_test_results_M2a}
df <- simtest3 %>% group_by(event) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))
myKable(df, digits=4) 
```

Everything is in good agreement.

## Simulation

We start in an error configuration, with both kinetochores connected to the same spindle:

```{r initial_configuration, fig.width=4, fig.height=2}
par <- parametersRates(2, 0.5, 1)
sc <- sisterChromatids(par, model="M1")
sc <- setErrorState(sc)
plotSisterChromatids(sc)
```

### Model 1

Here is an example of a simulation, showing the sequence of states for each kinetochore. The "L" or "R" in each state denotes the spindle to which the kinetochore is connected.

```{r simulation_example}
set.seed(102)
sc <- simulate("M1", par)
myKable(sc$timeline, bootstrap="hover")
```

Here is a graphical representation of this simulation run:

```{r simulation_example_plot, fig.width=8, fig.height=2}
plotStateHistory(sc) 
```

The final configuration is the correct "endon-L endon-R". 

```{r final_configuration, fig.width=4, fig.height=2}
plotSisterChromatids(sc)
```

### Model 2

Another example, this time for model 2.

```{r simulation_example_M2}
set.seed(110)
sc <- simulate("M2", par)
myKable(sc$timeline, bootstrap="hover")
```

```{r simulation_example_M2_plot, fig.width=8, fig.height=2}
plotStateHistory(sc) 
```


## Results

### Default parameters

```{r read_def_sims}
defsims <- readRDS(paste0(projectDir, "data/sim_defpar.rds"))
```



We run `r N(as.integer(nrow(defsims) / nlevels(defsims$model)))` simulations for the default parameters for model 1:

```{r default_parameters_m1}
myKable(defPars("M1"))
```

and for model 2:

```{r default_parameters_m2}
myKable(defPars("M2"))
```

Here is the distribution of simulation time.

```{r simulation_time_plot, fig.width=6, fig.height=3}
ggplot(defsims, aes(time)) +
  geom_histogram(bins=100) +
  facet_grid(. ~ model) +
  xlim(0, 40) +
  labs(x = "Time (min)", y = "Count")
```

Here is the mean and median simulation time for both models:

```{r simulation_median_time}
M <- lapply(c("mean", "median"), function(fun) {
  t <- t(as.matrix(tapply(defsims$time, defsims$model, fun)))
  rownames(t) <- fun
  round(t, 2)
})
df <- do.call(rbind, M)
myKable(df, row.names = TRUE)
```

### Grid of parameters

```{r read_all_sims}
allsims <- readRDS(paste0(projectDir, "data/sim_allpar.rds"))
```

```{r all_sims_mean}
allsim.means <- allsims %>% group_by(model, formation, conversion, detachment, knockoff, replacement) %>% summarise(mean.time = mean(time), se.time = sd(time) / sqrt(n()), n=n()) %>% as.data.frame
allsim.means <- allsim.means[order(allsim.means$mean.time), c(1:(ncol(allsim.means)-1))]
allsim.means.m1 <- allsim.means[allsim.means$model == "M1", c(M1.parnames, "mean.time", "se.time")]
allsim.means.m2 <- allsim.means[allsim.means$model == "M2", c(M2.parnames, "mean.time", "se.time")]
```


```{r simtime_function2}
getParameterGrid <- function(sim, model, parnames) {
  sim <- sim[sim$model == model, ]
  P <- setNames(lapply(parnames, function(p) {
    paste(sort(unique(sim[, p])), collapse=", ")
  }), parnames)
  df <- do.call(rbind, P)
}

plotParameterMeanTime <- function(sim, parnames) {
  P <- lapply(parnames, function(m) {
    df <- data.frame(x=as.factor(sim[, m]), y=sim$mean.time)
    ggplot(df, aes(x, y)) +
      geom_boxplot() +
      labs(x=m, y="mean time (min)") +
      scale_y_log10() +
      xlab(paste(m, "rate"))
  })
  grid.arrange(grobs=P, ncol=3)
}

plotFCsumDet <- function(sim) {
  sim$fc <- 1/sim$formation + 1/sim$conversion
  sim$detachment <- as.factor(sim$detachment)
  ggplot(sim) +
    geom_point(aes(x=fc, y=mean.time, colour=detachment)) +
    scale_y_log10() +
    labs(x="mean formation + mean conversion", y="mean time (min)")
}
```


#### Model 1

We run the simulation across a grid of parameters. This table show the rates used:

```{r parameter_grid_m1}
df <- getParameterGrid(allsim.means, "M1", M1.parnames)
myKable(df, row.names = TRUE)
```

Simply, we start from the default values and vary each parameter by factor two, up and down (except for knockoff). For each set we run `r N(as.integer(nrow(allsims) / nrow(allsim.means)))` simulations. The table below shows results ordered by the mean simulation time.

```{r all_sims_show_mean_m1}
kable(allsim.means.m1, format="html", row.names=FALSE, digits=2) %>% kable_styling("condensed", full_width = FALSE, position="left", font_size=12) %>% scroll_box(width="800 px", height = "400px") 
```

We can build a linear model to see which parameters are the most important:

```{r all_sims_linear_model_m1}
fit1 <- lm(mean.time ~ formation + conversion + detachment, data=allsim.means.m1)
summary(fit1)
```

And plot the dependence of the mean time against each parameter:

```{r all_sims_mean_plot_m1, fig.width=8, fig.height=3}
plotParameterMeanTime(allsim.means.m1, M1.parnames)
```

Now, conversion always follows formation and we think that the total duration of these two is important. Since our parameters are rates, mean formation and conversion times are $1/R_\mathrm{form}$ and $1/R_\mathrm{conv}$, respectively. Below, we plot the sum of both quantities on the x-axis and the mean simulation time on the y-axis. Colour correspond to different detachment rates.

```{r fc_det_plot, fig.width=5, fig.height=4}
plotFCsumDet(allsim.means.m1)
```

We need high formation and conversion rates, and, perhaps, a low detachment rate. Here is a heatmap of formation versus conversion, for fixed detachment rate of 0.5:

```{r heatmap_fc, fig.width=5, fig.height=4}
s <- subset(allsim.means.m1, detachment == 0.5)
s$conversion <- as.factor(s$conversion)
s$formation <- as.factor(s$formation)
ggplot(s) +
  geom_tile(aes(x=formation, y=conversion, fill=mean.time)) +
  labs(x="formation rate", y="conversion rate", fill="Mean time (min)") +
  scale_fill_viridis()
```


#### Model 2

Now, the same for model 2. Parameter grid:

```{r parameter_grid_m2}
df <- getParameterGrid(allsim.means, "M2", M2.parnames)
myKable(df, row.names = TRUE)
```

Table with ordered mean times:

```{r all_sims_show_mean_m2}
kable(allsim.means.m2, format="html", row.names=FALSE, digits=2) %>% kable_styling("condensed", full_width = FALSE, position="left", font_size=12) %>% scroll_box(width="800 px", height = "400px") 
```

Linear fit:

```{r all_sims_linear_model_m2}
fit1 <- lm(mean.time ~ replacement + knockoff + conversion, data=allsim.means.m2)
summary(fit1)
```

Parameter plot:

```{r all_sims_mean_plot_m2, fig.width=8, fig.height=3}
plotParameterMeanTime(allsim.means.m2, M2.parnames)
```

Here is the heatmap for knockoff rate fixed at 1e16 (no delay).

```{r heatmap_fc2, fig.width=5, fig.height=4}
s <- subset(allsim.means.m2, knockoff == 1e16)
s$conversion <- as.factor(s$conversion)
s$replacement <- as.factor(s$replacement)
ggplot(s) +
  geom_tile(aes(y=conversion, x=replacement, fill=mean.time)) +
  labs(y="conversion rate", x="replacement rate", fill="Mean time (min)") +
  scale_fill_viridis()
```


A few examples of simulation runs for a fast model 1 (that is $R_\mathrm{form}=1$, $R_\mathrm{conv}=2$ and $R_\mathrm{det}=0.5$):

```{r fast_simulations_examples, fig.width=10, fig.height=1.5}
set.seed(67)
for(i in 1:5) {
  sc <- simulate("M1", parametersRates(formation = 1, conversion = 2, detachment = 0.5))
  #print(sc$time)
  print(plotStateHistory(sc, max.time=17))
} 
```

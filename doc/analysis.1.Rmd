---
title: "Kinetochore-microtubule error correction"
subtitle: "Simple model"
author: "Marek Gierlinski"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    css: tabbed_notebook.css
  pdf_document:
    number_sections: yes
---

```{r options, echo=FALSE}
library(knitr)
library(kableExtra)
library(gridExtra)
suppressMessages(library(dplyr))
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  cache = TRUE
)
options(width = 1000)
options(knitr.table.format = "html")
```

```{css echo=FALSE}
pre code, pre, code {
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}
```

```{r kable_functions}
myKable <- function(df, row.names=FALSE, col.names=NA, digits=2, bootstrap="condensed") {
  kable(df, format="html", row.names=row.names, col.names=col.names, digits=digits) %>% kable_styling(bootstrap_options=bootstrap, full_width=FALSE, position="left", font_size=12)
}
```


Collaborators: Tomo Tanaka

[Proposal]()

Notebooks: [1]()

```{r setup, cache=FALSE, echo=FALSE}
source("../R/setup.R")
source("../R/lib.R")
source("../R/plots.R")
source("../R/tests.R")
```

# {.tabset}

## Model

There are two kinetochores, left and right. Each of them can be in one of the following attachment states:

- none
- lateral
- endon
- dual

In addition to this, we store information about which spindle the KT is connected to (left or right).

Transition between states are governed by a Poisson law. Each transition happens randomly a rate, $R$, expressed in events per minute.


### Model 1: "independent"

Here we assume that the end-on detachment and formation of the lateral attachment are independent. The sequence of events in this model is as follows. Here we only show how the model works on the left kinetochore, but obviously, it works on both.

Let's start with an unattached microtubule.

```{r default_parameters}
defaultParameters <- function() {
  parametersRates(
    formation = 2,
    conversion = 0.5,
    detachment = 1,
    knockoff = 1e16
  )
}
```

```{r plot_lateral_attachement, fig.width=4, fig.height=2}
par <- parametersRates(2, 0.5, 1)
sc <- sisterChromatids(par, model="independent")
plotSisterChromatids(sc)
```

A lateral attachment is created at a rate $R_{\rm lat}$.

```{r plot_emplty_sc, fig.width=4, fig.height=2}
sc <- formLateralAttachment(sc, "L", "L")
plotSisterChromatids(sc)
```

Next, the lateral attachment is converted into the end-on attachment, at a rate $R_{\rm con}$:

```{r plot_endon_attachement, fig.width=4, fig.height=2}
sc <- convertAttachment(sc, "L")
plotSisterChromatids(sc)
```

Finally, the end-on attachment is detached at a rate $R_{\rm det}$:

```{r plot_detachment, fig.width=4, fig.height=2}
sc <- detachKT(sc, "L")
plotSisterChromatids(sc)
```


### Model 2: "release"

In this model we assume that the end-on detachment happens only upon formation of the lateral attachment.  Hence, we never observe a detached state. This is the sequence of events. Now, we start with an end-on attachment:


```{r plot_endon_attachement_2, fig.width=4, fig.height=2}
sc <- sisterChromatids(par, model="release")
sc <- formLateralAttachment(sc, "L", "L")
sc <- convertAttachment(sc, "L")
plotSisterChromatids(sc)
```

Then, a lateral attachment can be created at the same KT, at a standard rate $R_{\rm lat}$. For a moment we have a "dual" attachment.

```{r plot_dual_attachement, fig.width=4, fig.height=2}
sc <- formDualAttachment(sc, "L", "L")
plotSisterChromatids(sc)
```

which, in turn, leads to the lateral attachment by knocking off the end-on MT. Here we assume no delay, though a knock-off rate $R_{\rm ko}$ can be introduced.

```{r plot_dual_detachment, fig.width=4, fig.height=2}
sc <- knockoffKT(sc, "L")
plotSisterChromatids(sc) 
```

As before, the lateral attachment is converted into end-on at a rate $R_{\rm con}$.

```{r plot_endon_attachement_3, fig.width=4, fig.height=2}
sc <- convertAttachment(sc, "L")
plotSisterChromatids(sc)
```

In this model, the detachment rate does not come into effect.

## Tests

We undertake a few simple tests to confirm that the model is working correctly. Specifically, we build the distribution of event duration over many simulation runs. The mean duration should be as in the input parameters. We set the following parameters: $R_{\rm lat} = 2~\rm{min}^{-1}$, $R_{\rm con} = 0.5~\rm{min}^{-1}$ and $R_{\rm det} = 1~\rm{min}^{-1}$. We keep large $R_{\rm del} = 10^{16}~\rm{min}^{-1}$, which corresponds to no delay.

```{r simulation_test_read}
simtest1 <- readRDS(paste0(projectDir, "data/sim_test1.rds"))
simtest2 <- readRDS(paste0(projectDir, "data/sim_test2.rds"))
simtest3 <- readRDS(paste0(projectDir, "data/sim_test3.rds"))
```

### Model 1

Here are measured distributions of event duration versus theoretical exponential distributions.

```{r simulation_test_results_independent_plot, fig.width=7, fig.height=3}
plotDurationDistribution(simtest1, par)
```

And these are mean of these distributions, which should correspond to 1 / rate (that is conversion = 2, detachment = 1 and formation = 0.5):

```{r simulation_test_results_independent}
df <- simtest1 %>% group_by(event) %>% summarise("mean duration"=mean(duration))
myKable(df, digits=3)
```

### Model 2

The same for the "release" model:

```{r simulation_test_results_release_plot, fig.width=7, fig.height=3}
plotDurationDistribution(simtest2, par)
```

and for the "release" model:

```{r simulation_test_results_release}
df <- simtest2 %>% group_by(event) %>% summarise("mean duration"=mean(duration))
myKable(df, digits=3)
```

They are reasonably close to the input parameters. In the second test the "knockoff" is very short: this corresponds to infinitesimal delay of detachment after lateral attachment. When we set a knockoff rate of 1 per minute, we get:

```{r simulation_test_results_release2_plot, fig.width=7, fig.height=3}
par2 <- parametersRates(2, 0.5, 1, 1)
plotDurationDistribution(simtest3, par2)
```


```{r simulation_test_results_release2}
df <- simtest3 %>% group_by(event) %>% summarise("mean duration"=mean(duration))
myKable(df, digits=3)
```


## Simulation

We start in an error configuration, with both kinetochores connected to the same spindle:

```{r initial_configuration, fig.width=4, fig.height=2}
par <- parametersRates(2, 0.5, 1)
sc <- sisterChromatids(par, model="independent")
sc <- setErrorState(sc)
plotSisterChromatids(sc)
```

### Model 1

Here is an example of a simulation, showing the sequence of states for each kinetochore. The "L" or "R" in each state denotes the spindle to which the kinetochore is connected.

```{r simulation_example}
set.seed(102)
sc <- simulate("independent", par)
myKable(sc$state.history, bootstrap="hover")
```

The final configuration is the correct "endon-L endon-R". 

```{r final_configuration, fig.width=4, fig.height=2}
plotSisterChromatids(sc)
```

### Model 2

Another example, this time for the "release" model.

```{r simulation_example_release}
set.seed(110)
sc <- simulate("release", par)
myKable(sc$state.history, bootstrap="hover")
```

## Results

### Default parameters

```{r read_def_sims}
defsims <- readRDS(paste0(projectDir, "data/sim_defpar.rds"))
```

We run `r N(as.integer(nrow(defsims) / nlevels(defsims$model)))` simulations for the default parameters ($R_{\rm lat} = 2~\rm{min}^{-1}$, $R_{\rm con} = 0.5~\rm{min}^{-1}$ and $R_{\rm det} = 1~\rm{min}^{-1}$). Here is the distribution of simulation time.

```{r simulation_time_plot, fig.width=6, fig.height=3}
ggplot(defsims, aes(time)) +
  geom_histogram(bins=100) +
  facet_grid(. ~ model) +
  xlim(0, 100)
```

Here is the mean and median simulation time for both models:

```{r simulation_median_time}
M <- lapply(c("mean", "median"), function(fun) {
  t <- t(as.matrix(tapply(defsims$time, defsims$model, fun)))
  rownames(t) <- fun
  round(t, 2)
})
df <- do.call(rbind, M)
myKable(df, row.names = TRUE)
```

### Grid of parameters

```{r read_all_sims}
allsims <- readRDS(paste0(projectDir, "data/sim_allpar.rds"))
```

```{r all_sims_mean}
allsim.means <- allsims %>% group_by(model, formation, conversion, detachment) %>% summarise(mean.time = mean(time), n=n()) %>% as.data.frame
allsim.means <- allsim.means[order(allsim.means$mean.time), c(1:(ncol(allsim.means)-1))]
```

We run the simulation across a grid of parameters. This table show the rates used:

```{r parameter_grid}
parnames <- c("formation", "conversion", "detachment")
P <- setNames(lapply(parnames, function(p) {
  paste(sort(unique(allsim.means[, p])), collapse=", ")
}), parnames)
df <- do.call(rbind, P)
myKable(df, row.names = TRUE)
```

Simply, we start from the default values and vary each parameter by factor two, up and down. This gives us $2 \times 5^3 = 250$ parameter sets for two models. For each set we run `r N(as.integer(nrow(allsims) / nrow(allsim.means)))` simulations. The table below shows results order by mean simulation time. We notice that the simualation time depends almost exclusively on the conversion rate, $r_\rm{con}$.

```{r all_sims_show_mean}
kable(allsim.means, format="html", row.names=FALSE, digits=2) %>% kable_styling("condensed", full_width = FALSE, position="left", font_size=12) %>% scroll_box(width="800 px", height = "400px") 
```

We can build a linear model to show this.

```{r all_sims_linear_model}
fit <- lm(mean.time ~ model + formation + conversion + detachment, data=allsim.means)
fit$call
anova(fit)
```

Indeed, conversion rate is much more important than anything else.

```{r all_sims_mean_plot}
P <- lapply(c("model", "formation", "conversion", "detachment"), function(m) {
  #df <- allsim.means %>% group_by_(.dots=m) %>% summarise("mean"=mean(mean.time))
  df <- data.frame(x=as.factor(allsim.means[, m]), y=allsim.means$mean.time)
  ggplot(df, aes(x, y)) +
    geom_boxplot() +
    labs(x=m, y="mean time") +
    scale_y_log10()
})
grid.arrange(grobs=P)
```
---
title: "Kinetochore-microtubule error correction"
subtitle: "Simple model"
author: "Marek Gierlinski"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    css: tabbed_notebook.css
  pdf_document:
    number_sections: yes
---

```{r options, echo=FALSE}
library(knitr)
library(kableExtra)
library(gridExtra)
library(ggridges)
suppressMessages(library(viridis))
suppressMessages(library(dplyr))
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  cache = TRUE
)
options(width = 1000)
options(knitr.table.format = "html")
```

```{css echo=FALSE}
pre code, pre, code {
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}
```

```{r kable_functions}
myKable <- function(df, row.names=FALSE, col.names=NA, digits=2, bootstrap="condensed") {
  kable(df, format="html", row.names=row.names, col.names=col.names, digits=digits) %>% kable_styling(bootstrap_options=bootstrap, full_width=FALSE, position="left", font_size=12)
}
```


Collaborators: Tomo Tanaka, Hari Doodhi

[Proposal]()

Notebooks: [1](http://www.compbio.dundee.ac.uk/user/mgierlinski/kinerr/doc/Notes.1.nb.html)

```{r setup, cache=FALSE, echo=FALSE}
source("../R/setup.R")
source("../R/lib.R")
source("../R/simdat.R")
source("../R/plots.R")
source("../R/tests.R") 
pdf.dir <- paste0(projectDir, "pdf/")
if(!dir.exists(pdf.dir)) dir.create(pdf.dir)
```

# {.tabset}

## Model

In this document we present a simple computer model for error correction in kinetochore-microtubule interaction during bi-orientation. The configuration is very simple, perhaps simplistic, but it can test the underlying mechanisms. We focus on two situations:

- KT detachment from MT ends creates unattached KTs before the next lateral attachment is formed (model "M1")
- End-on attachment is directly replaced by the lateral attachment without producing unattached KTs (model "M2")

### Setup

In our model there are two kinetochores, left and right. Each of them can be in one of the following attachment states:

- none
- lateral
- endon
- ambilink, synlink, biend

Dual attachments (ambilink, synlink, biend) represent the second model, when the lateral attachment is formed on top of the existing end-on attachment. In addition to the connection state, we also record which spindle pole (left or right) the kinetochore is attached to. Therefore, the state of the system can be briefly denoted as, e.g.:

```
lateral-R endon-R
```

The left KT has a lateral attachment to a microtubule extending from the right spindle. The right kinetochore has an end-on attachment to a microtubule extending from the right spindle.

### Dynamics

Transition between states are governed by a Poisson law. That is, at any given time the probability of transition from, e.g., lateral to end-on attachment is constant. Each transition happens randomly a rate, $R$, expressed in events per minute.

The model allows for other probability prescriptions, for example, the transition time can be expressed by a Gaussian probability.

The simulation is a sequence of events. The time of the next event is randomly drawn based on the current event and the probability law assumed. The events are generated for both kinetochores concurrently, until the final stable configuration is established (`endon-L endon-R`).

### Model 1

Here we assume that the end-on detachment and formation of the lateral attachment are independent. For illustration purposes, we show how the model works on the left kinetochore, but obviously, it works on both. Also, microtubules can reach kinetochores at the opposite side. The sequence of events in this model is as follows.

Let's start with an unattached microtubule.

```{r plot_lateral_attachement, fig.width=4, fig.height=2}
par <- defaultParameters()
sc <- sisterChromatids(par, model="M1")
plotSisterChromatids(sc, title="free") 
```

A lateral attachment is created at formation rate $R_\mathrm{form}$.

```{r plot_emplty_sc, fig.width=4, fig.height=2}
sc <- formLateralAttachment(sc, "A", "L")
plotSisterChromatids(sc, title="lateral") 
```

Next, the lateral attachment is converted into the end-on attachment, at conversion rate $R_\mathrm{conv}$:

```{r plot_endon_attachement, fig.width=4, fig.height=2}
sc <- convertAttachment(sc, "A")
plotSisterChromatids(sc, title="endon") 
```

Finally, the microtubule is detached at detachment rate $R_\mathrm{det}$:

```{r plot_detachment, fig.width=4, fig.height=2}
sc <- detachKT(sc, "A")
plotSisterChromatids(sc, title="free") 
```


### Model 2

In this model we assume that the end-on detachment happens only upon formation of the lateral attachment.  Hence, we never observe a detached state. This is the sequence of events. Now, we start with an end-on attachment:


```{r plot_endon_attachement_2, fig.width=4, fig.height=2}
sc <- sisterChromatids(par, model="M2")
sc <- formLateralAttachment(sc, "A", "L")
sc <- convertAttachment(sc, "A")
plotSisterChromatids(sc, title="endon")
```

#### Opposite side: lateral takeover

Then, a MT from the opposite spindle can make a lateral takeover, at replacement rate $R_\mathrm{rep}$. This is the same process as "formation" in model 1, but we call it "replacement" here, for distinction. For a moment we have an "ambilink" attachment.

```{r plot_ambilink_attachement, fig.width=4, fig.height=2}
sc <- formLinkAttachment(sc, "A", "R")
plotSisterChromatids(sc, title="ambilink")
```

The ambilink attachment is unstable and leads to the lateral attachment by knocking off the end-on MT at a rate $R_\mathrm{ko}$:

```{r plot_ambilink_ko, fig.width=4, fig.height=2}
sc <- knockoffKT(sc, "A")
plotSisterChromatids(sc, title="lateral") 
```

As before, the lateral attachment is converted into end-on at conversion rate $R_\mathrm{conv}$.

```{r plot_endon_attachement_3, fig.width=4, fig.height=2}
sc <- convertAttachment(sc, "A")
plotSisterChromatids(sc, title="endon") 
```


#### Same side: failed takeover

When the lateral takeover is atempted from the same side, it fails to knock-off the existing end-on attachment. Instead, a "synlink" attachment is formed (at replacement rate, $R_\mathrm{rep}$):

```{r plot_synlink_attachement, fig.width=4, fig.height=2}
sc <- sisterChromatids(par, model="M2")
sc <- formLateralAttachment(sc, "A", "L")
sc <- convertAttachment(sc, "A")
sc <- formLinkAttachment(sc, "A", "L")
plotSisterChromatids(sc, title="synlink") 
```

This works like a normal lateral attachment and is converted into endon at conversion rate $R_\mathrm{conv}$, except that at the end of the process a "biend" (bi-end-on) attachment is formed.

```{r plot_biend_attachement, fig.width=4, fig.height=2}
sc <- convertAttachment(sc, "A")
plotSisterChromatids(sc, title="biend") 
```

The new MT (the one that was trying to take over) is the detached at the knock-off rate $R_\mathrm{ko}$:

```{r plot_dual_detachment, fig.width=4, fig.height=2}
sc <- knockoffKT(sc, "A")
plotSisterChromatids(sc, title="endon")
```


In this model, the detachment rate does not come into effect.

## Conversion rate

### Old data

We estimate conversion rate (from lateral to end-on) from our old simulations of kinetochore-microtubule interaction. We use the latest results from the default parameter model in this file:

```{r kinetube_result_file}
file <- "/home/mgierlinski/projects/kinetube/varcap_grid/varcap8_slr2_short0.2_long0.5_ktd0.1_mtd0.03_rf0.3_resp0.6_inimt10_tau0.5_beta0.7/kinetube_all_kt.dat"
file
```

```{r kinetube_result}
kt <- read.delim(file, header=FALSE, comment="#", sep="")
sliding.time <- kt$V7
dropoff.time <- kt$V9
mean.sliding.time <-  mean(sliding.time[dropoff.time == 0])
rm(kt)
```

It contains several statistics for each kinetochore, over many simulations. Among them is the total sliding time. This is not exactly what we want, as this is the accumulated time, so includes KTs that were detached and re-attached. But the simulation also recorded the total drop-off time, that is the time the KT spend while being knocked-off before being re-attached. We select only data where total drop-off time is zero, which corresponds to KTs that have not been knocked-off. The mean sliding time from this file is `r round(mean.sliding.time, 2)` minutes, which gives the conversion rate of `r round(1/mean.sliding.time, 2)` per min.

### New runs

I modified the old simulation script to record conversion times, from onset of sliding until end-on conversion. This excludes pole capture. The new script is

```
/cluster/gjb_lab/mgierlinski/projects/kinetube/scripts/simconv.pl
```

and to run it on the cluster we used the following

```
qsub -q c6100.q,c6145.q -R y -V -cwd -t 1-100 ./scripts/simconv.pl -n -nsim=30 -delta=0.001 -poletransfer -ktexclusion -mtshrinkpole=0 -initialdiffusion=0.1 -maxtime=30 -alpha=1.57 -ktradrate=2 -mtdiffusion=0.03 -diffusion=0.1 -rfrate=0.3 -ktresprob=0.6 -inimt=10 -caprads=0.2 -capradl=0.5 -cumuldisttau=0.5 -beta=0.7 -dir=convrate -root=convrate
```

Technical note: I had to limit the queues, because all the jobs sent to c6320.q dies with "No such file or directory". I suspect Perl configuration is different on these nodes.

Here is the distribution of individual conversion times (the same distribution in linear of logarithmic scale):

```{r kinetube_conversion_time}
files <- dir("/home/mgierlinski/projects/kinetube/convrate", full.names=TRUE, pattern="conversions")
kinconv <- lapply(files, function(file) read.table(file, sep="\t", header=FALSE))
kinconv <- do.call(rbind, kinconv)
names(kinconv) <- c("batch", "sim", "kt", "time")
```

```{r plot_conversion_time_function}
plotConverstionTimeDistribution <- function(kinconv, log.scale=TRUE) {
  brks <- c(0.001, 0.01, 0.1, 1, 10)
  g <- ggplot(kinconv) +
    theme_classic() +
    geom_histogram(aes(x=time, y=..density..), bins=100) +
    labs(x="Conversion time (min)", y="Density")
  if(log.scale) g <- g + scale_x_log10(breaks=brks, labels=brks)
  g
}
```


```{r conversion_time_distribution, fig.width=8, fig.height=3}
mean.conv <- mean(kinconv$time)
conv.rate <- 1 / mean.conv
g1 <- plotConverstionTimeDistribution(kinconv, log.scale=FALSE)
g2 <- plotConverstionTimeDistribution(kinconv, log.scale=TRUE)
grid.arrange(g1, g2, ncol=2)
```

The mean conversion time is `r round(mean.conv, 3)` min, which gives conversion rate of `r round(conv.rate, 2)` per min.

## Tests

### "GenerateTime" function

First, I test my internal function for accuracy. Using all default parameters. The red curves show the theoretical exponential distribution.

```{r generate_time_test}
funtest <- readRDS(paste0(projectDir, "data/sim_test1.rds"))
```

```{r generate_time_test_plot, fig.width=8, fig.height=3}
par <- parametersRates()
plotDurationDistribution(funtest, par, ncol=5)
```

Here is a table with mean and SE for these:

```{r generate_time_test_table}
df <- funtest %>% group_by(event) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))
myKable(df, digits=4)
```

### Full simulation

We undertake a few simple tests to confirm that the model is working correctly. Specifically, we build the distribution of event duration over many simulation runs. The mean duration should be as in the input parameters. We set the following parameters: $R_\mathrm{form} = 0.5~\mathrm{min}^{-1}$, $R_\mathrm{conv} = 2~\mathrm{min}^{-1}$ and $R_\mathrm{det} = 1~\mathrm{min}^{-1}$.

```{r simulation_test_read}
simtest1 <- readRDS(paste0(projectDir, "data/sim_test2.rds"))
simtest2 <- readRDS(paste0(projectDir, "data/sim_test3.rds"))
simtest3 <- readRDS(paste0(projectDir, "data/sim_test4.rds"))
```

#### Model 1

Here are measured distributions of event duration versus theoretical exponential distributions.

```{r simulation_test_results_M1_plot, fig.width=7, fig.height=3}
par <- parametersRates(formation=0.5, conversion=2, detachment=1)
plotDurationDistribution(simtest1, par)
```

And these are mean of these distributions, which should correspond to 1 / rate (that is we expect means of conversion = 0.5, detachment = 1 and formation = 2):

```{r simulation_test_results_M1}
df <- simtest1 %>% group_by(event) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))
myKable(df, digits=4)
```

There is a good agreement between generated and theoretical means.

```{r random_generator_test, eval=FALSE}
rgTest <- function(n, rates=c(2, 1e16, 0.5)) {
  P <- lapply(1:n, function(i) {
    d <- lapply(rates, function(rate) {
      data.frame(
        rate=rate,
        duration=rexp(1, rate)
      )
    })
    do.call(rbind, d)
  })
  do.call(rbind, P)
}

rgt <- rgTest(1000)
df <- rgt %>% group_by(rate) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))

myKable(df, digits=4)
```


#### Model 2

The same for the "M2" model:

```{r simulation_test_results_M2_plot, fig.width=7, fig.height=3}
par <- parametersRates(replacement=0.5, conversion=2, knockoff=1)
plotDurationDistribution(simtest2, par)
```

and the mean times:

```{r simulation_test_results_M2}
df <- simtest2 %>% group_by(event) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))
myKable(df, digits=4)
```

They are reasonably close to the input parameters. In the second test the "knockoff" is very short: this corresponds to infinitesimal delay of detachment after lateral attachment. When we set a knockoff rate of 1 per minute, we get:

```{r simulation_test_results_M2a_plot, fig.width=7, fig.height=3}
par2 <- parametersRates(replacement=0.5, knockoff=1, conversion=2)
plotDurationDistribution(simtest3, par2)
```


```{r simulation_test_results_M2a}
df <- simtest3 %>% group_by(event) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))
myKable(df, digits=4) 
```

Everything is in good agreement.

## Simulation

We start in an error configuration, with both kinetochores connected to the same spindle:

```{r initial_configuration, fig.width=4, fig.height=2}
par <- parametersRates(2, 0.5, 1)
sc <- sisterChromatids(par, model="M1")
sc <- setErrorState(sc)
plotSisterChromatids(sc)
```

### Model 1

Here is an example of a simulation, showing the sequence of states for each kinetochore. The "L" or "R" in each state denotes the spindle to which the kinetochore is connected.

```{r simulation_example}
set.seed(113)
sc <- simulate("M1", par)
myKable(sc$timeline, bootstrap="hover")
```

Here is a graphical representation of this simulation run:

```{r simulation_example_plot, fig.width=8, fig.height=2}
plotStateHistory(sc)
```

The final configuration is the correct "endon-L endon-R" ("endon-R endon-L" is also considered final). 

```{r final_configuration, fig.width=4, fig.height=2}
plotSisterChromatids(sc) 
```

### Model 2

Another example, this time for model 2. Knockoff rate is high ($10$), hence "ambilink" and "biend" states are short.

```{r simulation_example_M2}
par <- parametersRates(2, 0.5, 1, 0.5, 10)
set.seed(111)
sc <- simulate("M2", par)
myKable(sc$timeline, bootstrap="hover")
```

```{r simulation_example_M2_plot, fig.width=8, fig.height=2}
plotStateHistory(sc)
```


## Default parameters

```{r read_all_sims}
allsims <- readRDS(paste0(projectDir, "data/sim_allpar.rds"))
time.m1 <- allsims$M1$time
time.m2 <- allsims$M2$time
det.m1 <- allsims$M1$detached
rm(allsims)
```

```{r select_defsim}
deftime.m1 <- defSelect(time.m1, "M1")
deftime.m2 <- defSelect(time.m2, "M2")
cls <- c("model", "set", "time")
deftime <- rbind(deftime.m1[, cls], deftime.m2[, cls])
```

### Model 1

Parameter sets:

```{r default_parameters_m1}
tab <- cbind(defParsTab("M1", 1), defParsTab("M1", 2)$value)
names(tab) <- c("parameter", "set 1", "set 2")
myKable(tab)
```

### Model 2

Parameter set 1:

```{r default_parameters_m2}
tab <- cbind(defParsTab("M2", 1), defParsTab("M2", 2)$value)
names(tab) <- c("parameter", "set 1", "set 2")
myKable(tab)
```

### Distribution of simulation time

Here are distributions of simulation time for both models (up and down) and parameter sets (fill colours). We show the same data in linear of logarithmic scale.

```{r defpar_plot, fig.width=9, fig.height=3}
g1 <- defparRidgePlot(deftime, log.scale=FALSE, limits=c(0,40))
g2 <- defparRidgePlot(deftime, log.scale=TRUE)
grid.arrange(g1, g2, ncol=2)
```

Here is the mean and median simulation time for 

```{r defpar_stats}
df1 <- defparStat(deftime.m1)
df2 <- defparStat(deftime.m2)
df <- rbind(df1, df2)
df <- cbind(model=c("M1", "M1", "M2", "M2"), df)
myKable(df, digits=1)
```


## Model 1

```{r m1_time_stats}
mtime.m1 <- time.m1 %>% group_by(formation, conversion, detachment) %>% summarise(mean.time = mean(time), se.time = sd(time) / sqrt(n()), median.time=median(time), median.detached.fraction=median(detached.duration/time), n=n()) %>% arrange(median.time) %>% as.data.frame
```

We run the simulation across a grid of parameters. This table show the rates used:

```{r M1_parameter_grid}
df <- getParameterGrid(mtime.m1, M1.parnames) 
myKable(df, row.names = TRUE)
```

Simply, we start from the default values and vary each parameter by factor two, up and down (except for knockoff). For each set we run `r N(mtime.m1[1, "n"])` simulations.

### Result table

The table below shows results ordered by the mean simulation time. There are `r N(nrow(mtime.m1))` combinations of the three parameters.

```{r M1_means_table}
kable(mtime.m1[, 1:7], format="html", row.names=FALSE, digits=2) %>% kable_styling("condensed", full_width = FALSE, position="left", font_size=12) %>% scroll_box(width="700px", height = "400px") 
```

```{r M1_all_sims_linear_model, eval=FALSE}
fit1 <- lm(median.time ~ formation + conversion + detachment, data=mtime.m1)
summary(fit1)
```

### Projection plots

Let's plot the dependence of the median time against each parameter. These plots show a projection of all data onto one parameter dimension.

```{r M1_all_sims_mean_plot, fig.width=9, fig.height=3}
plotParameterMedianTime(mtime.m1, M1.parnames)
```

Since we use quite wide range in each parameter, these plots are very scattered (vertically). This is because for one fixed value of a parameter (e.g. detachment rate of 4 in the right-hand panel) there is a large spread of simulation times due to the range of the other two parameters. These plots are not very informative, let's try something different.

### Line plots

Here is a plot of median time as a function of formation rate and conversion rate, for two selected values of the detachment rate.

```{r M1_two_par_plot, fig.width=8, fig.height=3}
g1 <- plotTwoPar(mtime.m1, "formation", "conversion", "detachment", 0.25, ylim=c(1, 400))
g2 <- plotTwoPar(mtime.m1, "formation", "conversion", "detachment", 2, ylim=c(1, 400))
grid.arrange(g1, g2, ncol=2)
```

Note that conversion and formation are symmetric, the plots look the same if we swap them.

```{r M1_two_par_plot_swapped, fig.width=8, fig.height=3}
g1 <- plotTwoPar(mtime.m1, "conversion", "formation", "detachment", 0.25, ylim=c(1, 400))
g2 <- plotTwoPar(mtime.m1, "conversion", "formation", "detachment", 2, ylim=c(1, 400))
grid.arrange(g1, g2, ncol=2)
```

This is because conversion always follows formation and what matters is the total duration of these two. Since our parameters are rates, mean formation and conversion times are $1/R_\mathrm{form}$ and $1/R_\mathrm{conv}$, respectively. Below, we plot the sum of both quantities on the x-axis and the median simulation time on the y-axis. Colour correspond to different detachment rates.

```{r M1_fc_det_plot, fig.width=5, fig.height=4}
plotFCsumDet(mtime.m1) 
```

For quick error correction we need high formation and conversion rates, and not very low detachment rate.

### Heatmaps

Here is a heatmap of formation rate versus conversion rate, for fixed detachment rates of 0.125 and 1. The colour scale and the numbers in boxes show the median simulation time.

```{r M1_heatmaps, fig.width=8, fig.height=3.5}
g1 <- plotTwoHeat(mtime.m1, "formation", "conversion", "detachment", 0.125, limits=c(0,225), midpoint=0.2, with.legend=FALSE)
g2 <- plotTwoHeat(mtime.m1, "formation", "conversion", "detachment", 1, limits=c(0,225), midpoint=0.2)
grid.arrange(g1, g2, ncol=2, widths=c(40,60)) 
```

The next heatmap shows conversion rate fixed at our best estimate of ~2 per min.

```{r M1_heatmap_conv2, fig.width=4.7, fig.height=3.5}
plotTwoHeat(mtime.m1, "formation", "detachment", "conversion", 2, limits=c(0,225), midpoint=0.2)
```

### Distribution plots

Here we plot distribution of individual simulation times for several sets of parameters. The vertical orange line indicates the median of the distribution.

```{r M1_plot_distribution_grid, fig.width=8, fig.height=12}
grid.par <- list(formation=c(0.25, 1, 4), conversion=c(1, 2, 4))
P <- lapply(c(0.125, 0.5, 2), function(d) {
  fixed.par <- list(detachment=d)
  plotDistributionGrid(time.m1, grid.par, fixed.par)
})
grid.arrange(grobs=P, ncol=1)
```

### Best parameters distribution plot

Here we create a plot for the paper. Following our previous simulations and Vanya's paper we fix $R_\mathrm{form} = 2~\mathrm{min}^{-1}$ and $R_\mathrm{conv} = 2~\mathrm{min}^{-1}$. Shuyu's observations suggest median bi-orientation time of about 1 min. Hence, for these two fixed parameters we seek the detachment rate with the median runtime closest to 1 min.

```{r M1_fig_best_parameters_search, fig.width=3, fig.height=3}
mm1.sel <- subset(time.m1, formation==2 & conversion==2)
plotBestTime(mm1.sel, "detachment", ylim=c(0.2, 200))
```

The best parameter is $R_\mathrm{det} = 1~\mathrm{min}^{-1}$. Here is the distribution of individual run times for this parameter:

```{r M1_fig_runtime_distribution, fig.width=4, fig.height=3}
m1.sel <- subset(time.m1, formation==2 & conversion==2 & detachment==1)
g <- plotDistributionPar(m1.sel, xlim=c(0.08, 30), show=5, bins=50)
g

file <- "M1_defpar.pdf"
pdf(paste0(pdf.dir, file), file, width=4, height=3)
g
dev.off()

link <- paste0("[PDF](", public_html, "pdf/", file, ")")
```

Here is a link to the figure: `r link`.

### Examples

A few examples of simulation runs for a fast model 1 (that is $R_\mathrm{form}=2$, $R_\mathrm{conv}=2$ and $R_\mathrm{det}=0.5$):

```{r M1_fast_simulations_examples, fig.width=10, fig.height=1.5}
set.seed(67)
for(i in 1:5) {
  sc <- simulate("M1", parametersRates(formation = 2, conversion = 2, detachment = 0.5))
  #print(sc$time)
  print(plotStateHistory(sc, max.time=15))
} 
```





## Model 2

```{r m2_time_stats}
mtime.m2 <- time.m2 %>% group_by(replacement, knockoff, conversion) %>% summarise(mean.time = mean(time), se.time = sd(time) / sqrt(n()), median.time=median(time), median.detached.fraction=median(detached.duration/time), n=n()) %>% arrange(median.time) %>% as.data.frame
```


Here is the grid of parameters for model 2:

```{r parameter_grid_m2}
df <- getParameterGrid(mtime.m2, M2.parnames)
myKable(df, row.names = TRUE) 
```

### Result table

There are `r N(nrow(mtime.m2))` combinations of the three parameters.

```{r all_sims_show_mean_m2}
kable(mtime.m2[, 1:6], format="html", row.names=FALSE, digits=2) %>% kable_styling("condensed", full_width = FALSE, position="left", font_size=12) %>% scroll_box(width="700px", height = "400px") 
```


```{r all_sims_linear_model_m2, eval=FALSE}
fit1 <- lm(mean.time ~ replacement + knockoff + conversion, data=mtime.m2)
summary(fit1)
```

### Projection plots

```{r all_sims_mean_plot_m2, fig.width=8, fig.height=3}
plotParameterMedianTime(mtime.m2, M2.parnames)
```

### Line plots

Here is a plot of median time as a function of replacement rate and conversion rate, for two selected values of the knockoff rate.

```{r M2_two_par_plot, fig.width=8, fig.height=3}
g1 <- plotTwoPar(mtime.m2, "replacement", "conversion", "knockoff", 1e16, ylim=c(0.5, 300))
g2 <- plotTwoPar(mtime.m2, "replacement", "conversion", "knockoff", 10, ylim=c(0.5, 300))
grid.arrange(g1, g2, ncol=2)
```

### Heatmaps

Here is the heatmap for knockoff rate fixed at 1e16 (no delay) and 1.

```{r M2_heatmaps, fig.width=8, fig.height=3.5}
g1 <- plotTwoHeat(mtime.m2, "replacement", "conversion", "knockoff", 1e16, limits=c(0,250), midpoint=0.2, with.legend = FALSE)
g2 <- plotTwoHeat(mtime.m2, "replacement", "conversion", "knockoff", 1, limits=c(0,250), midpoint=0.2)
grid.arrange(g1, g2, ncol=2, widths=c(40,60)) 
```

Very quick error correction times are achieved for high conversion rates. The knock-off delay has detrimental effect on these times.

The next heatmap shows conversion rate fixed at our best estimate of ~2 per min.

```{r M2_heatmap_conv2, fig.width=4.7, fig.height=3.5}
plotTwoHeat(mtime.m2, "replacement", "knockoff", "conversion", 2, limits=c(0,250), midpoint=0.2)
```


### Distribution plots

```{r M2_plot_distribution_grid, fig.width=8, fig.height=8}
grid.par <- list(replacement=c(0.25, 1, 4), conversion=c(1, 2, 4))
P <- lapply(c(1e16, 1), function(d) {
  fixed.par <- list(knockoff=d)
  plotDistributionGrid(time.m2, grid.par, fixed.par, xlim=c(0.01, 500))
})
grid.arrange(grobs=P, ncol=1) 
```

### Best parameters distribution plot

Here we create a plot for the paper. Following our previous simulations and Vanya's paper we fix $R_\mathrm{repl} = 2~\mathrm{min}^{-1}$ and $R_\mathrm{conv} = 2~\mathrm{min}^{-1}$. Shuyu's observations suggest median bi-orientation time of about 1 min. Hence, for these two fixed parameters we seek the detachment rate with the median runtime closest to 1 min.

```{r M2_fig_best_parameters_search, fig.width=3, fig.height=3}
mm2.sel <- subset(time.m2, replacement==2 & conversion==2)
plotBestTime(mm2.sel, "knockoff", ylim=c(0.1, 200))
```

The best parameter is $R_\mathrm{ko} = 10^{16}~\mathrm{min}^{-1}$. Here is the distribution of individual run times for this parameter:

```{r M2_fig_runtime_distribution, fig.width=4, fig.height=3}
m2.sel <- subset(time.m2, replacement==2 & conversion==2 & knockoff==1e16)
g <- plotDistributionPar(m2.sel, xlim=c(0.01, 20), show=5, bins=50)
g

file <- "M2_defpar.pdf"
pdf(paste0(pdf.dir, file), file, width=4, height=3)
g
dev.off()

link <- paste0("[PDF](", public_html, "pdf/", file, ")")
```

Here is a link to the figure: `r link`.



### Examples (instant knock-off)

A few examples of simulation runs for a fast model 2 (that is $R_\mathrm{repl}=2$, $R_\mathrm{conv}=2$ and $R_\mathrm{ko}=10^{16}$):

```{r M2_fast_simulations_examples, fig.width=10, fig.height=1.5}
set.seed(67)
for(i in 1:5) {
  sc <- simulate("M2", parametersRates(replacement = 2, conversion = 2, knockoff = 1e16))
  print(plotStateHistory(sc, max.time=6))
} 
```

### Examples (knock-off delay)

Here are examples as above, but with $R_\mathrm{ko}=1$:

```{r M2_fast_simulations_examples_ko1, fig.width=10, fig.height=1.5}
set.seed(12)
for(i in 1:5) {
  sc <- simulate("M2", parametersRates(replacement = 2, conversion = 2, knockoff = 1))
  #print(sc$time)
  print(plotStateHistory(sc, max.time=10))
} 
```


## Detached KTs

```{r detached_stats}
mdet.m1 <- det.m1 %>% group_by(formation, conversion, detachment) %>% summarise(median.detached.time=median(detached.time), n=n()) %>% arrange(median.detached.time) %>% as.data.frame
```


In this Section we investigate how long the system spends in configuration where both kinetochores are detached at the same time (model M1 only).

### Detached duration fraction

First, we calculate the fraction of the total time spend as fully detached. Here are plots showing the detached fraction across the range of parameters.

```{r detached_periods, fig.width=8, fig.height=3}
g1 <- plotTwoPar(mtime.m1, "detachment", "formation", "conversion", 2, val="median.detached.fraction", val.name="Median detached fraction", log.scale = FALSE)
g2 <- plotTwoPar(mtime.m1, "formation", "conversion", "detachment", 2, val="median.detached.fraction", val.name="Median detached fraction", log.scale = FALSE)
grid.arrange(g1, g2, ncol=2)
```

Detached periods are getting long for small formation rate and high detachment rate (as expected).

### Detached time distribution

Now, we turn to individual fully detached periods. We notice that the individual detached times depend almost exclusively on the formation rate. We can clearly see this when plotting median detached time:

```{r detachment_two_par_plot, fig.width=8, fig.height=3}
g1 <- plotTwoPar(mdet.m1, "formation", "conversion", "detachment", 1, val="median.detached.time", val.name="Median detached time (min)")
g2 <- plotTwoPar(mdet.m1, "formation", "detachment", "conversion", 2, val="median.detached.time", val.name="Median detached time (min)")
grid.arrange(g1, g2, ncol=2)
```


```{r detached_distribution_old, fig.width=8, fig.height=12, eval=FALSE}
grid.par <- list(formation=c(0.25, 1, 4), conversion=c(0.5, 2, 4))
P <- lapply(c(0.125, 0.5, 2), function(d) {
  fixed.par <- list(detachment=d)
  plotDistributionGrid(det.m1, grid.par, fixed.par, value="detached.time", xlim=c(0.002, 20))
})
grid.arrange(grobs=P, ncol=1)
```

Hence, we can simplify distribution plots. We fix $R_\mathrm{conv} = 2$ and $R_\mathrm{det} = 1~\mathrm{min}^{-1}$ and show the full range of formation rate (the same distribution in linear of logarithmic scale).

```{r plot_distribution_ridges_function}
plotDistributionRidges <- function(m, x, y, xlab, ylab, log.scale=TRUE, limits=c(0.001, 50), smooth=TRUE, binwidth=0.1) {
  brks <- c(0.001,0.01,0.1,1,10,100,1000)
  g <- ggplot(m, aes_string(x=x, y=y)) +
    theme_ridges(center_axis_labels = TRUE) +
    labs(x=xlab, y=ylab)
  if(smooth) {
    g <- g + geom_density_ridges()
  } else {
    g <- g + geom_density_ridges2(stat="binline", binwidth=binwidth)
  }
  if(log.scale) {
    g <- g + scale_x_log10(breaks=brks, labels=brks, limits=limits)
  } else {
    g <- g + xlim(limits)
  }
  g
}
```


```{r detached_distribution_time, fig.width=10, fig.height=4}
det.m1.sel <- det.m1 %>%
  filter(conversion == 2 & detachment == 1) %>%
  mutate(form = as.factor(formation), sigma = sqrt(6 * 0.1 * detached.time))
g2 <- plotDistributionRidges(det.m1.sel, "detached.time", "form", "Detached time (min)", expression(R[form]~(min^-1)))
g1 <- plotDistributionRidges(det.m1.sel, "detached.time", "form", "Detached time (min)", expression(R[form]~(min^-1)), log.scale=FALSE, limits=c(0,20), smooth=FALSE, binwidth=0.1)
grid.arrange(g1, g2, ncol=2)
```


### Diffusion distance scale

Next, we find the diffusion range, defined as $\sigma = \sqrt{6 D t}$, where $D = 0.1~\mu \mathrm{m}^2\mathrm{min}^{-1}$ is the diffusion coefficient and $t$ is the detachment time. We fix $R_\mathrm{conv} = 2$ and $R_\mathrm{det} = 1~\mathrm{min}^{-1}$ and show the full range of formation rate (the same distribution in linear of logarithmic scale).

```{r detached_distribution_distance, fig.width=10, fig.height=4}
sig1 <- median(det.m1.sel[det.m1.sel$formation == 1, "sigma"])
g2 <- plotDistributionRidges(det.m1.sel, "sigma", "form", expression(sigma~(mu*m)), expression(R[form]~(min^-1)))
g1 <- plotDistributionRidges(det.m1.sel, "sigma", "form", expression(sigma~(mu*m)), expression(R[form]~(min^-1)), log.scale=FALSE, limits=c(0,4), smooth=FALSE, binwidth=0.02)
grid.arrange(g1, g2, ncol=2)
```

Let us consider $R_\mathrm{form} = 1~\mathrm{min}^{-1}$. For this, the median diffusion range is $\sigma$ = `r round(sig1, 2)` $\mu$m. This is the standard deviation of the Gaussian distribution. Hence, about 95% of KTs will not strand farther than about $2\sigma$ = `r round(2*sig1, 2)` $\mu$m.

### Mean diffusion

Here we take the $\sigma$ distribution from the above figure (for each formation rate). Then, for each individual $\sigma$ from the distribution we build the corresponding Gaussian distribution, describing the local diffusion distance. We add up all the distributions to create a "pile-up". This describes the average distribution of diffusion distances across all observed detachment times. Here is the result. The vertical red lines show the size of the nucleus. Again, we fix $R_\mathrm{conv} = 2$ and $R_\mathrm{det} = 1~\mathrm{min}^{-1}$

```{r mean_distribution}
dx <- 0.01
x <- seq(from=-5, to=5, by=dx)
P <- mclapply(unique(det.m1.sel$formation), function(form) {
  sigmas <- det.m1.sel[det.m1.sel$formation == form, "sigma"]
  y <- x * 0
  for(s in sigmas) {
    y <- y + dnorm(x, mean=0, sd=s)
  }
  y <- y / (dx * sum(y))
  data.frame(formation=form, x=x, y=y)
}, mc.cores=6)
mdist <- do.call(rbind, P) 
```

```{r plot_mean_distribution, fig.width=4, fig.height=4}
rnuc <- 1.25
mdist$formation <- as.factor(mdist$formation)
ggplot(mdist) +
  theme_ridges(center_axis_labels = TRUE) +
  geom_ridgeline(aes(x=x, y=formation, height=y, group=formation), scale=1) +
  xlim(-1.5,1.5) +
  geom_vline(xintercept = c(-rnuc, rnuc), colour="red") +
  labs(x=expression(Distance~from~centre~(mu*m)), y=expression(R[form]~(min^-1)))
```

The table below shows the fraction of KTs that diffuse within the nucleus (that is, the area of each distribution within the red lines):

```{r table_mean_distribution}
msum <- mdist %>%
  group_by(formation) %>%
  filter(x > -rnuc & x < rnuc) %>%
  summarise(nucsum = sum(y) * dx) %>%
  arrange(desc(formation)) %>%
  as.data.frame %>% setNames(c("Form rate", "Fraction in nuc"))
myKable(msum)
```

## 16 chromosomes

The model described in this document simulates error correction for one chromosome (sister chromatids). In yeast, we have 16 chromosomes. What is the total time required to correct all chromosomes and establish proper bi-orientation? If error correction for all of them is done in parallel, then the total time is the longest of the individual times. We can model this by randomly sampling 16 timelines from our simulation results and finding the maximum time. NOTE: this is a very conservative approach assuming that *all* chromosomes start in an erroneous configuration.

```{r max_16_chromosomes_function}
maxChromosomes <- function(sim, pars, n.chromosomes=16, n.boot=1000, n.cores=7) {
  for(p in names(pars)) {
    val <- pars[[p]]
    sim <- sim[sim[[p]] == val,]
  }
  d <- mclapply(1:n.boot, function(i) {
    sample(sim$time, n.chromosomes)
  }, mc.cores = n.cores)
  unlist(d)
}

plotMaxChromosomes <- function(sim, model, pars) {
  brks <- c(0.01, 0.1, 1, 10, 100)
  m1.max <- maxChromosomes(sim, pars)
  #breaks <- seq(0, 25, 0.5)
  ggplot(data.frame(x=m1.max)) +
    geom_histogram(aes(x=x, y=..density..), bins=60) +
    labs(title=paste("Model", model), x="Max time (min)", y="Density") +
    scale_x_log10(breaks=brks, labels=brks, limits=c(0.1,50))
}
```

We select data with the following (default) parameters (units are 1 / minute).

- M1: $R_\mathrm{form} = 1$, $R_\mathrm{conv} = 2$, $R_\mathrm{det} = 1$
- M2: $R_\mathrm{repl} = 1$, $R_\mathrm{conv} = 2$, $R_\mathrm{ko} = 10$

These plots show the distribution of the maximum time across 16 randomly selected samples:

```{r M1_max_chr, fig.width=6, fig.height=3}
g1 <- plotMaxChromosomes(time.m1, "M1", list(formation=1, conversion=2, detachment=1))
g2 <- plotMaxChromosomes(time.m2, "M2", list(replacement=1, conversion=2, knockoff=10))
grid.arrange(g1, g2, ncol=2)
```


---
title: "Kinetochore-microtubule error correction"
subtitle: "Simple model"
author: "Marek Gierlinski"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    css: tabbed_notebook.css
  pdf_document:
    number_sections: yes
---

```{r options, echo=FALSE}
library(knitr)
library(kableExtra)
library(gridExtra)
suppressMessages(library(viridis))
suppressMessages(library(dplyr))
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  cache = TRUE
)
options(width = 1000)
options(knitr.table.format = "html")
```

```{css echo=FALSE}
pre code, pre, code {
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}
```

```{r kable_functions}
myKable <- function(df, row.names=FALSE, col.names=NA, digits=2, bootstrap="condensed") {
  kable(df, format="html", row.names=row.names, col.names=col.names, digits=digits) %>% kable_styling(bootstrap_options=bootstrap, full_width=FALSE, position="left", font_size=12)
}
```


Collaborators: Tomo Tanaka

[Proposal]()

Notebooks: [1](http://www.compbio.dundee.ac.uk/user/mgierlinski/kinerr/doc/Notes.1.nb.html)

```{r setup, cache=FALSE, echo=FALSE}
source("../R/setup.R")
source("../R/lib.R")
source("../R/simdat.R")
source("../R/plots.R")
source("../R/tests.R")
```

# {.tabset}

## Model

In this document we present a simple computer model for error correction in kinetochore-microtubule interaction during bi-orientation. The configuration is very simple, perhaps simplistic, but it can test the underlying mechanisms. We focus on two situations:

- KT detachment from MT ends creates unattached KTs before the next lateral attachment is formed (model "M1")
- End-on attachment is directly replaced by the lateral attachment without producing unattached KTs (model "M2")

### Setup

In our model there are two kinetochores, left and right. Each of them can be in one of the following attachment states:

- none
- lateral
- endon
- dual

Dual attachment represents the second model, when the lateral attachment is formed on top of the existing end-on attachment. In addition to the connection state, we also record which spindle pole (left or right) the kinetochore is attached to. Therefore, the state of the system can be briefly denoted as, e.g.:

```
lateral-R endon-R
```

The left KT has a lateral attachment to a microtubule extending from the right spindle. The right kinetochore has an end-on attachment to a microtubule extending from the right spindle.

### Dynamics

Transition between states are governed by a Poisson law. That is, at any given time the probability of transition from, e.g., lateral to end-on attachment is constant. Each transition happens randomly a rate, $R$, expressed in events per minute.

The model allows for other probability prescriptions, for example, the transition time can be expressed by a Gaussian probability.

The simulation is a sequence of events. The time of the next event is randomly drawn based on the current event and the probability law assumed. The events are generated for both kinetochores concurrently, until the final stable configuration is established (`endon-L endon-R`).

### Model 1

Here we assume that the end-on detachment and formation of the lateral attachment are independent. For illustration purposes, we show how the model works on the left kinetochore, but obviously, it works on both. Also, microtubules can reach kinetochores at the opposite side. The sequence of events in this model is as follows.

Let's start with an unattached microtubule.

```{r plot_lateral_attachement, fig.width=4, fig.height=2}
par <- defaultParameters()
sc <- sisterChromatids(par, model="M1")
plotSisterChromatids(sc)
```

A lateral attachment is created at formation rate $R_\mathrm{form}$.

```{r plot_emplty_sc, fig.width=4, fig.height=2}
sc <- formLateralAttachment(sc, "L", "L")
plotSisterChromatids(sc)
```

Next, the lateral attachment is converted into the end-on attachment, at conversion rate $R_\mathrm{conv}$:

```{r plot_endon_attachement, fig.width=4, fig.height=2}
sc <- convertAttachment(sc, "L")
plotSisterChromatids(sc)
```

Finally, the microtubule is detached at detachment rate $R_\mathrm{det}$:

```{r plot_detachment, fig.width=4, fig.height=2}
sc <- detachKT(sc, "L")
plotSisterChromatids(sc)
```


### Model 2

In this model we assume that the end-on detachment happens only upon formation of the lateral attachment.  Hence, we never observe a detached state. This is the sequence of events. Now, we start with an end-on attachment:


```{r plot_endon_attachement_2, fig.width=4, fig.height=2}
sc <- sisterChromatids(par, model="M2")
sc <- formLateralAttachment(sc, "L", "L")
sc <- convertAttachment(sc, "L")
plotSisterChromatids(sc)
```

Then, a lateral attachment can be created at the same KT, at replacement rate $R_\mathrm{rep}$. This is the same process as "formation" in model 1, but we call it "replacement" here, for distinction. For a moment we have a "dual" attachment.

```{r plot_dual_attachement, fig.width=4, fig.height=2}
sc <- formDualAttachment(sc, "L", "L")
plotSisterChromatids(sc)
```

which, in turn, leads to the lateral attachment by knocking off the end-on MT. Here we assume no delay, though a knock-off rate $R_\mathrm{ko}$ can be introduced.

```{r plot_dual_detachment, fig.width=4, fig.height=2}
sc <- knockoffKT(sc, "L")
plotSisterChromatids(sc) 
```

As before, the lateral attachment is converted into end-on at conversion rate $R_\mathrm{conv}$.

```{r plot_endon_attachement_3, fig.width=4, fig.height=2}
sc <- convertAttachment(sc, "L")
plotSisterChromatids(sc)
```

In this model, the detachment rate does not come into effect.

## Conversion rate

We estimate conversion rate (from lateral to end-on) from our old simulations of kinetochore-microtubule interaction. We use the latest results from the default parameter model in this file:

```{r kinetube_result_file}
file <- "/home/mgierlinski/projects/kinetube/varcap_grid/varcap8_slr2_short0.2_long0.5_ktd0.1_mtd0.03_rf0.3_resp0.6_inimt10_tau0.5_beta0.7/kinetube_all_kt.dat"
file
```

```{r kinetube_result}
kt <- read.delim(file, header=FALSE, comment="#", sep="")
sliding.time <- kt$V7
dropoff.time <- kt$V9
mean.sliding.time <-  mean(sliding.time[dropoff.time == 0])
rm(kt)
```

It contains several statistics for each kinetochore, over many simulations. Among them is the total sliding time. This is not exactly what we want, as this is the accumulated time, so includes KTs that were detached and re-attached. But the simulation also recorded the total drop-off time, that is the time the KT spend while being knocked-off before being re-attached. We select only data where total drop-off time is zero, which corresponds to KTs that have not been knocked-off. The mean sliding time from this file is `r round(mean.sliding.time, 2)` minutes, which gives the conversion rate of `r round(1/mean.sliding.time, 2)` per min.

## Tests

### "GenerateTime" function

First, I test my internal function for accuracy. Using all default parameters. The red curves show the theoretical exponential distribution.

```{r generate_time_test}
funtest <- readRDS(paste0(projectDir, "data/sim_test1.rds"))
```

```{r generate_time_test_plot, fig.width=8, fig.height=3}
plotDurationDistribution(funtest, par, ncol=5)
```

Here is a table with mean and SE for these:

```{r generate_time_test_table}
df <- funtest %>% group_by(event) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))
myKable(df, digits=4)
```

### Full simulation

We undertake a few simple tests to confirm that the model is working correctly. Specifically, we build the distribution of event duration over many simulation runs. The mean duration should be as in the input parameters. We set the following parameters: $R_\mathrm{form} = 0.5~\mathrm{min}^{-1}$, $R_\mathrm{conv} = 2~\mathrm{min}^{-1}$ and $R_\mathrm{det} = 1~\mathrm{min}^{-1}$.

```{r simulation_test_read}
simtest1 <- readRDS(paste0(projectDir, "data/sim_test2.rds"))
simtest2 <- readRDS(paste0(projectDir, "data/sim_test3.rds"))
simtest3 <- readRDS(paste0(projectDir, "data/sim_test4.rds"))
```

#### Model 1

Here are measured distributions of event duration versus theoretical exponential distributions.

```{r simulation_test_results_M1_plot, fig.width=7, fig.height=3}
par <- defaultParameters()
plotDurationDistribution(simtest1, par)
```

And these are mean of these distributions, which should correspond to 1 / rate (that is we expect means of conversion = 0.5, detachment = 1 and formation = 2):

```{r simulation_test_results_M1}
df <- simtest1 %>% group_by(event) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))
myKable(df, digits=4)
```

There is a good agreement between generated and theoretical means.

```{r random_generator_test, eval=FALSE}
rgTest <- function(n, rates=c(2, 1e16, 0.5)) {
  P <- lapply(1:n, function(i) {
    d <- lapply(rates, function(rate) {
      data.frame(
        rate=rate,
        duration=rexp(1, rate)
      )
    })
    do.call(rbind, d)
  })
  do.call(rbind, P)
}

rgt <- rgTest(1000)
df <- rgt %>% group_by(rate) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))

myKable(df, digits=4)
```


#### Model 2

The same for the "M2" model:

```{r simulation_test_results_M2_plot, fig.width=7, fig.height=3}
par <- defaultParameters()
plotDurationDistribution(simtest2, par)
```

and the mean times:

```{r simulation_test_results_M2}
df <- simtest2 %>% group_by(event) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))
myKable(df, digits=4)
```

They are reasonably close to the input parameters. In the second test the "knockoff" is very short: this corresponds to infinitesimal delay of detachment after lateral attachment. When we set a knockoff rate of 1 per minute, we get:

```{r simulation_test_results_M2a_plot, fig.width=7, fig.height=3}
par2 <- parametersRates(replacement=0.5, knockoff=1, conversion=2)
plotDurationDistribution(simtest3, par2)
```


```{r simulation_test_results_M2a}
df <- simtest3 %>% group_by(event) %>% summarise("mean duration"=mean(duration), SE=sd(duration) / sqrt(n()))
myKable(df, digits=4) 
```

Everything is in good agreement.

## Simulation

We start in an error configuration, with both kinetochores connected to the same spindle:

```{r initial_configuration, fig.width=4, fig.height=2}
par <- parametersRates(2, 0.5, 1)
sc <- sisterChromatids(par, model="M1")
sc <- setErrorState(sc)
plotSisterChromatids(sc)
```

### Model 1

Here is an example of a simulation, showing the sequence of states for each kinetochore. The "L" or "R" in each state denotes the spindle to which the kinetochore is connected.

```{r simulation_example}
set.seed(113)
sc <- simulate("M1", par)
myKable(sc$timeline, bootstrap="hover")
```

Here is a graphical representation of this simulation run:

```{r simulation_example_plot, fig.width=8, fig.height=2}
plotStateHistory(sc)
```

The final configuration is the correct "endon-L endon-R" ("endon-R endon-L" is also considered final). 

```{r final_configuration, fig.width=4, fig.height=2}
plotSisterChromatids(sc) 
```

### Model 2

Another example, this time for model 2. Knockoff rate is very high ($10^{16}$), hence there is no "dual" state observed.

```{r simulation_example_M2}
set.seed(111)
sc <- simulate("M2", par)
myKable(sc$timeline, bootstrap="hover")
```

```{r simulation_example_M2_plot, fig.width=8, fig.height=2}
plotStateHistory(sc)
```


## Default parameters

```{r read_all_sims}
allsims <- readRDS(paste0(projectDir, "data/sim_allpar.rds"))
time.m1 <- allsims$M1$time
time.m2 <- allsims$M2$time
det.m1 <- allsims$M1$detached
rm(allsims)
```

```{r select_defsim}
deftime.m1 <- defSelect(time.m1, "M1")
deftime.m2 <- defSelect(time.m2, "M2")
```

### Model 1

Parameter set 1:

```{r default_parameters_m1.1}
myKable(defParsTab("M1", 1))
```

Parameter set 2:

```{r default_parameters_m1.2}
myKable(defParsTab("M1", 2))
```

Here is the distribution of simulation time. Panels show parameter set 1 and 2.

```{r defpar_plot_function}
defparPlot <- function(deftime) {
  ggplot(deftime, aes(time)) +
    geom_histogram(bins=60) +
    facet_grid(. ~ set) +
    xlim(0, 40) +
    labs(x = "Time (min)", y = "Count")
}

defparStat <- function(deftime) {
  P <- lapply(1:2, function(set) {
    x <- deftime[deftime$set == set,]
    data.frame(
      set = set,
      mean = mean(x$time),
      median = median(x$time)
    )
  })
  df <- do.call(rbind, P)
}
```

```{r m1_defpar_plot, fig.width=6, fig.height=3}
defparPlot(deftime.m1)
```

Here is the mean and median simulation time for both models:

```{r m1_defpar_stats}
df <- defparStat(deftime.m1)
myKable(df)
```



### Model 2

Parameter set 1:

```{r default_parameters_m2.1}
myKable(defParsTab("M2", 1))
```

Parameter set 2:

```{r default_parameters_m2.2}
myKable(defParsTab("M2", 2))
```

Here is the distribution of simulation time. Panels show parameter set 1 and 2.

```{r m2_defpar_plot, fig.width=6, fig.height=3}
defparPlot(deftime.m2)
```

Here is the mean and median simulation time for both models:

```{r m2_defpar_stats}
df <- defparStat(deftime.m2)
myKable(df)
```



## Model 1

```{r m1_time_stats}
mtime.m1 <- time.m1 %>% group_by(formation, conversion, detachment) %>% summarise(mean.time = mean(time), se.time = sd(time) / sqrt(n()), median.time=median(time), median.detached.fraction=median(detached.duration/time), n=n()) %>% arrange(median.time) %>% as.data.frame
```


```{r simtime_functions}
getParameterGrid <- function(sim, parnames) {
  P <- setNames(lapply(parnames, function(p) {
    paste(sort(unique(sim[, p])), collapse=", ")
  }), paste(parnames, "rate"))
  df <- do.call(rbind, P)
}
```

We run the simulation across a grid of parameters. This table show the rates used:

```{r M1_parameter_grid}
df <- getParameterGrid(mtime.m1, M1.parnames) 
myKable(df, row.names = TRUE)
```

Simply, we start from the default values and vary each parameter by factor two, up and down (except for knockoff). For each set we run `r N(mtime.m1[1, "n"])` simulations.

### Result table

The table below shows results ordered by the mean simulation time.

```{r M1_means_table}
kable(mtime.m1, format="html", row.names=FALSE, digits=2) %>% kable_styling("condensed", full_width = FALSE, position="left", font_size=12) %>% scroll_box(width="700px", height = "400px") 
```

```{r M1_all_sims_linear_model, eval=FALSE}
fit1 <- lm(median.time ~ formation + conversion + detachment, data=mtime.m1)
summary(fit1)
```

### Projection plots

Let's plot the dependence of the median time against each parameter. These plots show a projection of all data onto one parameter dimension.

```{r M1_all_sims_mean_plot, fig.width=9, fig.height=3}
plotParameterMedianTime(mtime.m1, M1.parnames)
```

Since we use quite wide range in each parameter, these plots are very scattered (vertically). This is because for one fixed value of a parameter (e.g. detachment rate of 4 in the right-hand panel) there is a large spread of simulation times due to the range of the other two parameters. These plots are not very informative, let's try something different.

### Line plots

Here is a plot of median time as a function of formation rate and conversion rate, for two selected values of the detachment rate.

```{r M1_two_par_plot, fig.width=8, fig.height=3}
g1 <- plotTwoPar(mtime.m1, "formation", "conversion", "detachment", 0.25, ylim=c(1, 400))
g2 <- plotTwoPar(mtime.m1, "formation", "conversion", "detachment", 2, ylim=c(1, 400))
grid.arrange(g1, g2, ncol=2)
```

Note that conversion and formation are symmetric, the plots look the same if we swap them.

```{r M1_two_par_plot_swapped, fig.width=8, fig.height=3}
g1 <- plotTwoPar(mtime.m1, "conversion", "formation", "detachment", 0.25, ylim=c(1, 400))
g2 <- plotTwoPar(mtime.m1, "conversion", "formation", "detachment", 2, ylim=c(1, 400))
grid.arrange(g1, g2, ncol=2)
```

This is because conversion always follows formation and what matters is the total duration of these two. Since our parameters are rates, mean formation and conversion times are $1/R_\mathrm{form}$ and $1/R_\mathrm{conv}$, respectively. Below, we plot the sum of both quantities on the x-axis and the median simulation time on the y-axis. Colour correspond to different detachment rates.

```{r M1_fc_det_plot, fig.width=5, fig.height=4}
plotFCsumDet(mtime.m1) 
```

For quick error correction we need high formation and conversion rates, and not very low detachment rate.

### Heatmaps

Here is a heatmap of formation rate versus conversion rate, for fixed detachment rates of 0.125 and 1. The colour scale and the numbers in boxes show the median simulation time.

```{r M1_heatmaps, fig.width=8, fig.height=3.5}
g1 <- plotTwoHeat(mtime.m1, "formation", "conversion", "detachment", 0.125, limits=c(0,215), midpoint=0.2, with.legend=FALSE)
g2 <- plotTwoHeat(mtime.m1, "formation", "conversion", "detachment", 1, limits=c(0,215), midpoint=0.2)
grid.arrange(g1, g2, ncol=2, widths=c(40,60)) 
```

The next heatmap shows conversion rate fixed at our best estimate of ~2 per min.

```{r M1_heatmap_conv2, fig.width=4.7, fig.height=3.5}
plotTwoHeat(mtime.m1, "formation", "detachment", "conversion", 2, limits=c(0,215), midpoint=0.2)
```

### Distribution plots

Here we plot distribution of individual simulation times for several sets of parameters. The vertical orange line indicates the median of the distribution.

```{r M1_plot_distribution_grid, fig.width=8, fig.height=12}
grid.par <- list(formation=c(0.25, 1, 4), conversion=c(0.25, 1, 4))
P <- lapply(c(0.125, 0.5, 2), function(d) {
  fixed.par <- list(detachment=d)
  plotDistributionGrid(time.m1, grid.par, fixed.par)
})
grid.arrange(grobs=P, ncol=1)
```


### Detached periods

Next, we investigate how long the system spends in configuration where both kinetochores are detached at the same time. We calculate the fraction of the total time spend as fully detached. Here are plots showing the detached fraction across the range of parameters.

```{r detached_periods, fig.width=8, fig.height=3}
g1 <- plotTwoPar(mtime.m1, "detachment", "formation", "conversion", 2, val="median.detached.fraction", val.name="Median detached fraction", log.scale = FALSE)
g2 <- plotTwoPar(mtime.m1, "formation", "conversion", "detachment", 2, val="median.detached.fraction", val.name="Median detached fraction", log.scale = FALSE)
grid.arrange(g1, g2, ncol=2)
```

Detached periods are getting long for small formation rate and high detachment rate (as expected).

Below are plots of distribution of individual detachment times. We notice that they depend almost exclusively on the formation rate.

```{r detached_distribution, fig.width=8, fig.height=12}
grid.par <- list(formation=c(0.25, 1, 4), conversion=c(0.25, 1.5, 4))
P <- lapply(c(0.125, 0.5, 2), function(d) {
  fixed.par <- list(detachment=d)
  plotDistributionGrid(det.m1, grid.par, fixed.par, value="detached.time", xlim=c(0.002, 20))
})
grid.arrange(grobs=P, ncol=1)
```

Next, we find the diffusion range, defined as $\sigma = \sqrt{6 D t}$, where $D = 0.1~\mu \mathrm{m}^2\mathrm{min}^{-1}$ is the diffusion coefficient ant $t$ is the detachment time.

```{r detached_distribution_distance, fig.width=8, fig.height=3}
det.m1$sigma = sqrt(6 * 0.1 * det.m1$detached.time)
grid.par <- list(formation=c(0.25, 1, 4), conversion=c(1.5))
fixed.par <- list(detachment=c(1))
plotDistributionGrid(det.m1, grid.par, fixed.par, value="sigma", xlab=expression(sigma~(mu*m)), xlim=c(0.005, 3))
```


### Examples

A few examples of simulation runs for a fast model 1 (that is $R_\mathrm{form}=2$, $R_\mathrm{conv}=2$ and $R_\mathrm{det}=0.5$):

```{r M1_fast_simulations_examples, fig.width=10, fig.height=1.5}
set.seed(67)
for(i in 1:5) {
  sc <- simulate("M1", parametersRates(formation = 2, conversion = 2, detachment = 0.5))
  #print(sc$time)
  print(plotStateHistory(sc, max.time=15))
} 
```





## Model 2

```{r m2_time_stats}
mtime.m2 <- time.m2 %>% group_by(replacement, knockoff, conversion) %>% summarise(mean.time = mean(time), se.time = sd(time) / sqrt(n()), median.time=median(time), median.detached.fraction=median(detached.duration/time), n=n()) %>% arrange(median.time) %>% as.data.frame
```


Here is the grid of parameters for model 2:

```{r parameter_grid_m2}
df <- getParameterGrid(mtime.m2, M2.parnames)
myKable(df, row.names = TRUE) 
```

### Result table

```{r all_sims_show_mean_m2}
kable(mtime.m2, format="html", row.names=FALSE, digits=2) %>% kable_styling("condensed", full_width = FALSE, position="left", font_size=12) %>% scroll_box(width="700px", height = "400px") 
```


```{r all_sims_linear_model_m2, eval=FALSE}
fit1 <- lm(mean.time ~ replacement + knockoff + conversion, data=mtime.m2)
summary(fit1)
```

### Projection plots

```{r all_sims_mean_plot_m2, fig.width=8, fig.height=3}
plotParameterMedianTime(mtime.m2, M2.parnames)
```

### Line plots

Here is a plot of median time as a function of replacement rate and conversion rate, for two selected values of the knockoff rate.

```{r M2_two_par_plot, fig.width=8, fig.height=3}
g1 <- plotTwoPar(mtime.m2, "replacement", "conversion", "knockoff", 1e16, ylim=c(0.7, 300))
g2 <- plotTwoPar(mtime.m2, "replacement", "conversion", "knockoff", 1, ylim=c(0.7, 300))
grid.arrange(g1, g2, ncol=2)
```

### Heatmaps

Here is the heatmap for knockoff rate fixed at 1e16 (no delay) and 1.

```{r M2_heatmaps, fig.width=8, fig.height=3.5}
g1 <- plotTwoHeat(mtime.m2, "replacement", "conversion", "knockoff", 1e16, limits=c(0,250), midpoint=0.2, with.legend = FALSE)
g2 <- plotTwoHeat(mtime.m2, "replacement", "conversion", "knockoff", 1, limits=c(0,250), midpoint=0.2)
grid.arrange(g1, g2, ncol=2, widths=c(40,60)) 
```

Very quick error correction times are achieved for high conversion rates. The knock-off delay has detrimental effect on these times.

The next heatmap shows conversion rate fixed at our best estimate of ~2 per min.

```{r M2_heatmap_conv2, fig.width=4.7, fig.height=3.5}
plotTwoHeat(mtime.m2, "replacement", "knockoff", "conversion", 2, limits=c(0,250), midpoint=0.2)
```


### Distribution plots

```{r M2_plot_distribution_grid, fig.width=8, fig.height=8}
grid.par <- list(replacement=c(0.25, 1, 4), conversion=c(0.25, 1, 4))
P <- lapply(c(1e16, 1), function(d) {
  fixed.par <- list(knockoff=d)
  plotDistributionGrid(time.m2, grid.par, fixed.par, xlim=c(0.01, 500))
})
grid.arrange(grobs=P, ncol=1) 
```


### Examples (instant knock-off)

A few examples of simulation runs for a fast model 2 (that is $R_\mathrm{repl}=2$, $R_\mathrm{conv}=2$ and $R_\mathrm{ko}=1e16$):

```{r M2_fast_simulations_examples, fig.width=10, fig.height=1.5}
set.seed(67)
for(i in 1:5) {
  sc <- simulate("M2", parametersRates(replacement = 2, conversion = 2, knockoff = 1e16))
  print(plotStateHistory(sc, max.time=6))
} 
```

### Examples (knock-off delay)

Here are examples as above, but with $R_\mathrm{ko}=1$:

```{r M2_fast_simulations_examples_ko1, fig.width=10, fig.height=1.5}
set.seed(12)
for(i in 1:5) {
  sc <- simulate("M2", parametersRates(replacement = 2, conversion = 2, knockoff = 1))
  #print(sc$time)
  print(plotStateHistory(sc, max.time=10))
} 
```

## 16 chromosomes

The model described in this document simulates error correction for one chromosome (sister chromatids). In yeast, we have 16 chromosomes. What is the total time required to correct all chromosomes and establish proper bi-orientation? If error correction for all of them is done in parallel, then the total time is the longest of the individual times. We can model this by randomly sampling 16 timelines from our simulation results and finding the maximum time. NOTE: this is a very conservative approach assuming that *all* chromosomes start in an erroneous configuration.

```{r max_16_chromosomes_function}
maxChromosomes <- function(sim, pars, n.chromosomes=16, n.boot=1000, n.cores=7) {
  for(p in names(pars)) {
    val <- pars[[p]]
    sim <- sim[sim[[p]] == val,]
  }
  d <- mclapply(1:n.boot, function(i) {
    sample(sim$time, n.chromosomes)
  }, mc.cores = n.cores)
  unlist(d)
}

plotMaxChromosomes <- function(sim, model, pars) {
  m1.max <- maxChromosomes(sim, pars)
  breaks <- seq(0, 20, 0.5)
  ggplot(data.frame(x=m1.max)) +
    geom_histogram(aes(x=x, y=..density..), breaks=breaks) +
    labs(title=paste("Model", model), x="Max time (min)", y="Density")
}
```

We select data with the following parameters (units are 1 / minute). They correspond to rather fast error correction times of a few minutes.

- M1: $R_\mathrm{form} = 2$, $R_\mathrm{conv} = 2$, $R_\mathrm{det} = 0.5$
- M2: $R_\mathrm{repl} = 2$, $R_\mathrm{conv} = 2$, $R_\mathrm{ko} = 10^{16}$

These plots show the distribution of the maximum time across 16 randomly selected samples:

```{r M1_max_chr, fig.width=6, fig.height=3}
g1 <- plotMaxChromosomes(time.m1, "M1", list(formation=2, conversion=2, detachment=0.5))
g2 <- plotMaxChromosomes(time.m2, "M2", list(replacement=2, conversion=2, knockoff=1e16))
grid.arrange(g1, g2, ncol=2)
```

